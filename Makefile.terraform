# This makefile is intended to enable Terraform repositories.
# We've had some success with using it manually and with Jenkins.
#

## Override any of the below ?= variables in .config.mk
-include .config.mk

TERRAFORM_IMAGE ?= docker.io/hashicorp/terraform
TERRAFORM_VERSION ?= 1.0.7 ## Terraform is very version specific, so know what you need
TERRAFORM_STATE_S3 ?= yes ## If using S3 for shared state, override this with a 'yes'
CONTAINER_ENGINE ?= docker ## Commands will be executed via the container engine, expected to be docker cli compatible
CONTAINER_WORK_DIR ?= /data
CONTAINER_ENV ?= .env

BASE_ENV := -v ~/.aws:/root/.aws:Z --env-file=$(CONTAINER_ENV)
BASE_WORKDIR := -w $(CONTAINER_WORK_DIR) -v "$(CURDIR)":$(CONTAINER_WORK_DIR):Z
# Container based commands to for use handling target steps
BASE_COMMAND := $(CONTAINER_ENGINE) run --rm -it $(BASE_ENV) $(BASE_WORKDIR)
TERRAFORM_COMMAND := $(BASE_COMMAND) $(TERRAFORM_IMAGE):$(TERRAFORM_VERSION)

# Determine some runtime values
ifeq (".terraform/environment", "$(wildcard .terraform/environment)")
	# if file exists on disk, get the workspace from it
	TERRAFORM_VAR_FILE := -var-file=$(shell cat .terraform/environment).tfvars
endif

all: help

.PHONY:.check-env
.check-env:
ifeq ($(origin TERRAFORM_STATE_S3), "yes")
	@if [ "${AWS_PROFILE}" == "" ]; then \
		if [ "${AWS_SECRET_ACCESS_KEY}" == "" ] || [ "${AWS_ACCESS_KEY_ID}" == "" ]; then \
			echo "ERROR: AWS_PROFILE _or_ AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY must be profiled"; \
			exit 1; \
		fi; \
	fi
endif

.PHONY: help
help:   ## Show this help, includes list of all actions.
	@awk 'BEGIN {FS = ":.*?## "}; /^.+: .*?## / && !/awk/ {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' ${MAKEFILE_LIST}

.PHONY: clean
clean: ## Cleanup the local checkout
	-rm -f *.zip *.backup .terraform

$(CONTAINER_ENV):
	@env | awk '!/TOKEN/ && /^(AWS)/ { print }' | sort > $(@)

.terraform: $(BUILD_ENV)
	@if [ ! -d .terraform ]; then $(TERRAFORM_COMMAND) init; else $(TERRAFORM_COMMAND) get --update > /dev/null; fi

.PHONY: init
init: .terraform ## Initalize shared storage bucket for state and ensure modules are loaded

.PHONY: list-workspaces
list-workspaces: init ## Displays list of workspaces
	$(TERRAFORM_COMMAND) workspace list

.PHONY: new-workspace-%
new-workspace-%: init ## Creates and selects a new workspace
	$(TERRAFORM_COMMAND) workspace new $*

.PHONY: select-%
select-%: init ## Change to the provided workspace
	$(TERRAFORM_COMMAND) workspace select $*

plan-%: select-% plan ## Run terraform plan against the defined workspace
	: # This is because make doesnt like wildcard targets to not have any actions

plan: init  ## Run terraform plan against the current workspace
	$(TERRAFORM_COMMAND) plan $(TERRAFORM_VAR_FILE)

test: plan ## Standard entry point for running tests. Calls plan

apply-%: select-% apply ## Run terraform apply against the defined workspace
	: # This is because make doesnt like this target to not have any actions

apply: init ## Run terraform apply against the current workspace
	$(TERRAFORM_COMMAND) apply $(TERRAFORM_VAR_FILE)

show: init ## Run terraform show against the current workspace
	$(TERRAFORM_COMMAND) show

show-node: init ## Run terraform show against the current workspace. NODE_REGEX search pattern
	$(TERRAFORM_COMMAND) show | grep -P '^module| id| ip' | grep -C1 -P "${NODE_REGEX}"

taint-node: init ## Run terraform taint against the current workspace. NODE_REGEX search pattern
	./scripts/taint.sh $(TERRAFORM_COMMAND) ${NODE_REGEX}
